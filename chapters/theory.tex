\chapter{Θεωρητικό Υπόβαθρο}

Η εξέλιξη των Κυβερνο-Φυσικών Συστημάτων (CPS) και των εφαρμογών IoT βασίζεται
σε θεμελιώδεις αρχιτεκτονικές αρχές που συνδυάζουν την αποδοτική διαχείριση της
φυσικής πληροφορίας με τις δυνατότητες της σύγχρονης υπολογιστικής τεχνολογίας.
Σε αυτό το κεφάλαιο παρουσιάζονται τα βασικά αρχιτεκτονικά μοντέλα, οι μέθοδοι
διασύνδεσης υποσυστημάτων και τα πρότυπα διαχείρισης δεδομένων που επικρατούν
στα σύγχρονα CPS.

\section{Κυβερνο-Φυσικά Συστήματα: Ορισμοί και Χαρακτηριστικά}

\subsection{Θεμελιώδεις Ορισμοί}

Τα \textbf{Κυβερνο-Φυσικά Συστήματα} (Cyber-Physical Systems, CPS) αποτελούν
ενσωματωμένα υπολογιστικά συστήματα που παρακολουθούν και ελέγχουν φυσικές
διεργασίες μέσω στενής αλληλεπίδρασης μεταξύ κυβερνητικών (υπολογιστικών) και
φυσικών στοιχείων. Σε αντίθεση με τα παραδοσιακά ενσωματωμένα συστήματα, τα CPS
χαρακτηρίζονται από τα παρακάτω σημεία:

\begin{itemize}
    \item \textbf{Κλειστοί βρόχοι ελέγχου (closed-loop control)}: Η έξοδος του
	    φυσικού συστήματος τροφοδοτείται πίσω στο υπολογιστικό σύστημα,
	    δημιουργώντας συνεχή κύκλο αισθητήρων-επεξεργασίας-ενεργοποιητών.
    \item \textbf{Αλληλεπίδραση πολλαπλών κλιμάκων}: Τα CPS λειτουργούν σε
	    διαφορετικές χωρικές (από νανο-αισθητήρες έως περιφερειακά δίκτυα)
	    και χρονικές (από μικροδευτερόλεπτα έως μήνες) κλίμακες.
    \item \textbf{Δικτυωμένη λειτουργία}: Η δυνατότητα επικοινωνίας και
	    συντονισμού μεταξύ κατανεμημένων στοιχείων είναι εγγενής στον
	    σχεδιασμό τους.
    \item \textbf{Χρονικοί περιορισμοί}: Πολλές λειτουργίες απαιτούν εγγυήσεις
	    πραγματικού χρόνου (hard/soft real-time constraints).
\end{itemize}

\subsection{Διαστάσεις Πολυπλοκότητας στα CPS}

Η πολυπλοκότητα των CPS προκύπτει από την αλληλεπίδραση πολλών παραγόντων:

\paragraph{Ετερογένεια:} Τα CPS ενσωματώνουν ετερογενή υπολογιστικά μοντέλα
(event-driven, time-triggered, dataflow), πρωτόκολλα επικοινωνίας (MQTT, CoAP,
HTTP) και φυσικά υποστρώματα (μηχανικά, ηλεκτρικά, χημικά συστήματα).

\paragraph{Μη-ντετερμινισμός:} Οι φυσικές διεργασίες εμφανίζουν στοχαστική
συμπεριφορά, θόρυβο μετρήσεων και καθυστερήσεις επικοινωνίας, καθιστώντας τον
προγραμματισμό απόλυτα καθοριστικών συμπεριφορών αδύνατο.

\paragraph{Κατανεμημένη κατάσταση:} Η κατάσταση του συστήματος κατανέμεται σε
πολλαπλούς κόμβους, απαιτώντας πρωτόκολλα συγχρονισμού και μηχανισμούς
συνέπειας (consistency protocols).

\subsection{Μοντέλα Αναφοράς για CPS}

Διάφορα ερευνητικά και βιομηχανικά μοντέλα αναφοράς έχουν προταθεί για την
οργάνωση της αρχιτεκτονικής των CPS:

\paragraph{Τριεπίπεδο Μοντέλο (Three-Tier Model):}
\begin{itemize}
    \item \textbf{Φυσικό Επίπεδο (Physical Layer)}: Αισθητήρες, ενεργοποιητές,
        φυσικές διεργασίες
    \item \textbf{Επίπεδο Δικτύου (Network Layer)}: Πρωτόκολλα επικοινωνίας,
        gateways, edge computing nodes
    \item \textbf{Κυβερνητικό Επίπεδο (Cyber Layer)}: Αλγόριθμοι ελέγχου,
        ανάλυση δεδομένων, λήψη αποφάσεων
\end{itemize}

\paragraph{Πενταεπίπεδη Αρχιτεκτονική 5C (5C Architecture):}
Το μοντέλο 5C επεκτείνει το τριεπίπεδο μοντέλο με:
\begin{enumerate}
    \item \textbf{Connection Layer}: Έξυπνη συλλογή και μετάδοση δεδομένων
    \item \textbf{Conversion Layer}: Εξαγωγή πληροφορίας από δεδομένα
    \item \textbf{Cyber Layer}: Δημιουργία ψηφιακών δίδυμων (digital twins)
    \item \textbf{Cognition Layer}: Παραγωγή γνώσης και σύγκριση με παρόμοια
        συστήματα
    \item \textbf{Configuration Layer}: Αυτο-διαμόρφωση και αυτο-βελτιστοποίηση
\end{enumerate}

\section{Αρχιτεκτονικές Μοτίβα για Κατανεμημένα CPS}

\subsection{Layered Architecture (Στρωματοποιημένη Αρχιτεκτονική)}

Η στρωματοποιημένη αρχιτεκτονική οργανώνει το σύστημα σε ιεραρχικά επίπεδα με
σαφή διαχωρισμό ευθυνών:

\paragraph{Φυσικό Επίπεδο (Physical Layer):}
\begin{itemize}
    \item Αισθητήρες: Θερμοκρασίας, υγρασίας, pH, πίεσης, κίνησης
    \item Ενεργοποιητές: Ηλεκτροβάνες, κινητήρες, ρελέ
    \item Φυσικές διεργασίες: Καλλιέργειες, μηχανήματα, δίκτυα ύδρευσης
\end{itemize}

\paragraph{Επίπεδο Διασύνδεσης (Connectivity Layer):}
\begin{itemize}
    \item Ασύρματα πρωτόκολλα: LoRaWAN, Zigbee, Bluetooth LE
    \item Ενσύρματα: Ethernet, RS-485
    \item Πύλες IoT: Protocol translation, buffering, edge processing
\end{itemize}

\paragraph{Επίπεδο Ροής Δεδομένων (Data Flow Layer):}
\begin{itemize}
    \item Message brokers: Apache Kafka, RabbitMQ
    \item Stream processors: Apache Flink, Kafka Streams
    \item Event buses: Pub/Sub mechanisms
\end{itemize}

\paragraph{Επίπεδο Υπηρεσιών (Service Layer):}
\begin{itemize}
    \item APIs: RESTful, GraphQL, gRPC
    \item Microservices: Ανεξάρτητες, κλιμακούμενες υπηρεσίες
    \item Business logic: Κανόνες, workflows, αυτοματισμοί
\end{itemize}

\paragraph{Επίπεδο Παρουσίασης (Presentation Layer):}
\begin{itemize}
    \item Dashboards: Grafana, custom web UIs
    \item Mobile applications
    \item Notification systems
\end{itemize}

\section{Streams, Event-Driven και Batch vs Real-Time Processing}

Η \textit{ροή δεδομένων} (stream) αποτελεί μια συνεχώς εξελισσόμενη αλληλουχία
τιμών που παράγονται από αισθητήρες, ενσωματωμένες συσκευές ή άλλες πηγές και
διακινούνται ασύγχρονα εντός του συστήματος. Η συνεχής ροή επιβάλλει μοντέλο
επεξεργασίας όπου τα δεδομένα αντιμετωπίζονται ως διαρκές σήμα και όχι ως
στατικά σύνολα προς περιοδική ανάλυση. Η \textbf{event-driven αρχιτεκτονική}
αξιοποιεί αυτό το σήμα ώστε κάθε νέο γεγονός να ενεργοποιεί αμέσως έναν
υπολογισμό, μια σειρά κανόνων (rules), ενημερώσεις ή οποιεσδήποτε άλλες
ελεγκτικές ενέργειες. Η μηδενική ανοχή σε καθυστερήσεις είναι θεμελιώδης σε
πεδία όπως η γεωργία ακριβείας, το predictive maintenance, ο βιομηχανικός
αυτοματισμός και οι αυτόνομες πλατφόρμες, όπου η πληροφορία χάνει αξία όταν
παλιώνει ακόμη και κατά μερικά δευτερόλεπτα.

Τα παραδοσιακά \textit{batch} συστήματα λειτουργούν με συγκεντρωτικές παρτίδες
δεδομένων, δημιουργώντας αμετάβλητη καθυστέρηση. Το μοντέλο αυτό επαρκεί μόνο
όταν οι απαιτήσεις απόκρισης είναι χαμηλές ή όταν το κόστος λάθους δεν είναι
κρίσιμο. Σε CPS, όμως, η καθυστέρηση ενός batch κύκλου ισοδυναμεί με απώλεια
συστημικής επίγνωσης και αδυναμία δυναμικής προσαρμογής. Η μετάβαση σε
\textbf{stream processing} (με αρχιτεκτονικές Lambda/Kappa) ελαχιστοποιεί το
latency και επιτρέπει συνεχή αξιολόγηση της κατάστασης του συστήματος.

Η λογική ροών συνεπάγεται ανάγκη για stateful operators, μηχανισμούς windowing,
backpressure και αποδοτική ανοχή σφαλμάτων, ώστε το σύστημα να παραμένει
λειτουργικό υπό πίεση και ασταθείς ροές εισόδου. Η αλλαγή παραδείγματος από
batch σε stream δεν αφορά μόνο τη χρονική διάσταση, αλλά και τον τρόπο
μοντελοποίησης της πραγματικότητας: το σύστημα αντιμετωπίζει τα δεδομένα ως
ζωντανή, κινούμενη πληροφορία και όχι ως στατικό αρχείο προς εκ των υστέρων
επεξεργασία. Αυτό οδηγεί σε αρχιτεκτονικές που μπορούν να επιβάλλουν αυτονομία,
να προσαρμόζονται στο περιβάλλον και να διατηρούν συστημική συνοχή χωρίς
εξάρτηση από περιοδικούς κύκλους επανυπολογισμού.

\section{Αρχιτεκτονικές Streams: Lambda και Kappa}

Οι δύο επικρατέστερες αρχιτεκτονικές για επεξεργασία ροών αντιμετωπίζουν το
ίδιο πρόβλημα (συνεχή, ασύγχρονη ροή δεδομένων) με διαφορετική φιλοσοφία ως
προς την οργάνωση, την ακρίβεια και το λειτουργικό κόστος.

\begin{itemize}
	\item \textbf{Lambda}: Διατηρεί δύο παράλληλα επίπεδα. Το \textit{speed
		layer} επεξεργάζεται γεγονότα σχεδόν στιγμιαία, προσφέροντας
		γρήγορα αλλά ενδεχομένως προσεγγιστικά αποτελέσματα. Το
		\textit{batch layer} αναλαμβάνει ακριβή, πλήρη ανάλυση πάνω σε
		ολόκληρο το ιστορικό, ώστε τα τελικά δεδομένα να είναι συνεπή
		ακόμη κι όταν το \textit{fast path} παράγει προσεγγίσεις. Η
		αρχιτεκτονική αυτή παρέχει ισορροπία μεταξύ απόδοσης και
		ακρίβειας, αλλά εισάγει αυξημένη πολυπλοκότητα λόγω διπλής
		υλοποίησης λογικής και ανάγκης συγχρονισμού των
		\textit{layers}.
	\item \textbf{Kappa}: Επιλέγει ενιαίο μοντέλο ροών. Όλα τα δεδομένα
		αντιμετωπίζονται ως \textit{streams}, τόσο για
		\textit{real-time} όσο και για \textit{reprocessing}. Η
		επανεπεξεργασία επιτυγχάνεται απλώς με επανάγνωση του
		\textit{log} των γεγονότων, χωρίς ξεχωριστού \textit{batch}
		υποσυστήματος. Το αποτέλεσμα είναι απλούστερη λειτουργική δομή,
		ομοιομορφία στον κώδικα και ελαχιστοποίηση των σημείων
		ασυνέπειας που προκύπτουν από διπλές υλοποιήσεις. Η
		\textit{Kappa} απαιτεί ισχυρό και ανθεκτικό \textit{log} (π.χ.
		Kafka) και \textit{stateful stream processors} με ικανότητα
		διαχείρισης μεγάλης κατάστασης.
\end{itemize}

Η επιλογή μεταξύ των δύο εξαρτάται από την ανοχή του συστήματος σε καθυστέρηση
και από το κόστος που είναι διατεθειμένο να πληρώσει ο σχεδιαστής, σε
πολυπλοκότητα. Η \textbf{Lambda} ταιριάζει σε περιβάλλοντα όπου οι αναλυτικές
εργασίες απαιτούν \textbf{πλήρη ακρίβεια}, χωρίς να θυσιάζεται η άμεση
απόκριση. Η \textbf{Kappa} είναι καταλληλότερη όταν προέχει η
\textbf{απλότητα}, η ενιαία λογική και η δυνατότητα συνεχούς επεξεργασίας χωρίς
παράλληλες ροές υποδομής.

Σε πρακτικό επίπεδο, συστήματα όπως το \textit{Apache Kafka} λειτουργούν ως
\textit{durable logs} που επιτρέπουν στον επεξεργαστή ροών να αναπαράγει την
κατάσταση οποιαδήποτε στιγμή \cite{alang2025stream}. Πάνω σε αυτό το υπόβαθρο,
πλατφόρμες όπως \textit{Apache Flink} και \textit{Apache Spark} διαχειρίζονται
παραθυροποιήσεις (\textit{windows}), \textit{stateful operators}, χρονικές
εγγυήσεις (\textit{event-time processing}), ακριβή \textit{semantics} παράδοσης
(ακριβώς μια φορά) και μηχανισμούς \textit{backpressure}. Αυτό επιτρέπει στις
αρχιτεκτονικές \textit{Lambda} και \textit{Kappa} να λειτουργούν σε κλίμακα, να
επιβάλλουν συνεκτική συμπεριφορά σε ασταθή περιβάλλοντα ρυθμού και να
διασφαλίζουν ότι οι ροές δεδομένων παραμένουν χρήσιμες ακόμη και όταν οι πηγές
εισόδου είναι απρόβλεπτες.

Οι δύο προσεγγίσεις δεν απαιτούν διαφορετική φιλοσοφία ως προς τα εργαλεία,
αλλά διαφορετική στάση απέναντι στη μοντελοποίηση της πληροφορίας: υβριδική
διπλή ανάλυση στη μία περίπτωση, μονολιθική αντίληψη ροής στην άλλη.

\section{Διασύνδεση Υποσυστημάτων}

Για την αλληλεπίδραση πολλαπλών, ετερογενών υποσυστημάτων, το
\textbf{publish/subscribe} μοτίβο προσφέρει έναν θεμελιώδη μηχανισμό ασύγχρονης
επικοινωνίας, επιτρέποντας χαλαρά συνδεδεμένες (\textit{loosely coupled})
υπηρεσίες. Κάθε παραγωγός (\textit{publisher}) μπορεί να στέλνει μηνύματα χωρίς
να γνωρίζει τους καταναλωτές (\textit{subscribers}) και αντίστροφα, διατηρώντας
την αυτονομία των υποσυστημάτων, διευκολύνοντας την επεκτασιμότητα και
επιτρέποντας αλλαγές στην τοπολογία χωρίς κεντρικό συντονισμό.

Η ποιότητα υπηρεσίας (\textit{Quality of Service, QoS}) αποκτά κρίσιμη σημασία
σε περιβάλλοντα με αστάθεια σύνδεσης ή περιορισμένους πόρους. Η επιλογή μεταξύ
fire-and-forget, τουλάχιστον-μία-φορά (at-least-once) ή ακριβώς-μία-φορά
(exactly-once) παράδοσης μηνυμάτων καθορίζει την αξιοπιστία και την
ανθεκτικότητα των εφαρμογών. Σε low-power ή low-bandwidth δίκτυα, πρωτόκολλα
όπως το \textit{MQTT} και το \textit{CoAP} μειώνουν το overhead, υποστηρίζοντας
ελαφριά, αξιόπιστη και ασφαλή ανταλλαγή μηνυμάτων.

Πέρα από την αξιοπιστία, η διαχείριση backpressure, η αποθήκευση προσωρινών
μηνυμάτων (message buffering) και η δυνατότητα replay είναι κρίσιμα στοιχεία
για τη διατήρηση συνέπειας σε συστήματα με υψηλή μεταβλητότητα φόρτου. Η χρήση
ιεραρχιών των topics και φιλτραρίσματος επιτρέπει στους καταναλωτές
(subscribers) να λαμβάνουν μόνο τα δεδομένα που τους ενδιαφέρουν, μειώνοντας
τον όγκο μεταφερόμενων μηνυμάτων και το latency.

Επιπλέον, η συνδυαστική χρήση pub/sub με event-driven αρχιτεκτονικές ενισχύει
τη δυνατότητα real-time αντίδρασης σε γεγονότα. Η ενσωμάτωση μηχανισμών
παρακολούθησης και metrics (π.χ. latency ανά topic, ακυρωμένα μηνύματα)
επιτρέπει την ενεργή βελτιστοποίηση της επικοινωνίας και την προσαρμογή σε
μεταβαλλόμενες συνθήκες δικτύου ή φόρτου.

Τελικά, η διασύνδεση υποσυστημάτων σε CPS απαιτεί προσεκτική ισορροπία μεταξύ
αυτονομίας, αξιοπιστίας, latency και κατανάλωσης πόρων, με δυνατότητα
κλιμάκωσης και επαναδιαμόρφωσης χωρίς διακοπή λειτουργίας.

\section{Αποθήκευση, Consistency Models και Caching}

Η αποθήκευση δεδομένων σε CPS αποτελεί κρίσιμη πρόκληση λόγω του όγκου, της
ταχύτητας παραγωγής και της ανάγκης για real-time προσπέλαση. Κατανεμημένα
συστήματα βάσεων δεδομένων, όπως NoSQL ή wide-column stores, χρησιμοποιούν
replication, partitioning και sharding για να διασφαλίσουν υψηλή διαθεσιμότητα,
fault tolerance και οριζόντια κλιμάκωση. Η επιλογή wide-column store γίνεται
συχνά για την υποστήριξη μεγάλων ροών δεδομένων με ευέλικτο σχήμα και
αποτελεσματική οργάνωση ανά χρονικά διαστήματα (\textit{date bucketing}),
επιτρέποντας ταχεία προσπέλαση σε ιστορικά δεδομένα χωρίς να επηρεάζεται η
απόδοση των real-time queries.

Η τεχνική του \textbf{date bucketing} οργανώνει τα δεδομένα σε χρονικούς
“κουβάδες” ή partitions (π.χ. ανά ημέρα, ώρα ή λεπτό), μειώνοντας το εύρος
σάρωσης (scan range) κατά την ανάκτηση ή ανάλυση μεγάλων όγκων δεδομένων. Σε
συνδυασμό με wide-column stores, κάθε bucket μπορεί να αποθηκεύει σειρές και
στήλες που αντιστοιχούν σε γεγονότα ή μετρήσεις συγκεκριμένης χρονικής
περιόδου, διευκολύνοντας τόσο batch αναλύσεις όσο και real-time streaming
queries χωρίς να απαιτείται πλήρης αναδιάταξη ή ανακατασκευή των δεδομένων.

Η επιλογή \textbf{consistency model} παραμένει κρίσιμη. Το strong consistency
εξασφαλίζει ότι όλοι οι κόμβοι βλέπουν την ίδια κατάσταση, ενώ το eventual
consistency μειώνει latency και αυξάνει διαθεσιμότητα, αποδεχόμενο προσωρινή
ασυνέπεια. Causal και session-based models προσφέρουν ενδιάμεσες λύσεις,
διατηρώντας λογική αλληλουχία γεγονότων χωρίς πλήρη συγχρονισμό.

Το \textit{in-memory caching} (Redis, Memcached) μειώνει δραστικά το latency
για συχνά προσπελαύσιμα δεδομένα, ενώ στρατηγικές όπως write-through ή
write-back ελέγχουν την αντοχή σε αποτυχίες. Η συνδυαστική χρήση cache με date
bucketing επιτρέπει την άμεση πρόσβαση σε “hot” χρονικά διαστήματα χωρίς να
επηρεάζεται η αποδοτικότητα ανάκτησης ιστορικών δεδομένων.

Σε CPS πραγματικού χρόνου, η οργάνωση δεδομένων με \textit{date bucketing}
διευκολύνει επίσης τα \textit{stream processing pipelines}, επιτρέποντας εύκολη
επανεπεξεργασία γεγονότων σε συγκεκριμένα χρονικά διαστήματα χωρίς να
επηρεάζεται η συνολική δομή της βάσης. Παρακολούθηση μετρικών όπως
\textit{bucket size}, \textit{cache hit/miss ratio} και \textit{latency}
επιτρέπει τη βελτιστοποίηση της υποδομής και τη δυναμική προσαρμογή σε
μεταβαλλόμενο φόρτο.

Η στρατηγική αυτή διασφαλίζει ισορροπία μεταξύ \textit{latency, consistency,
durability} και κλιμάκωσης, ενώ εκμεταλλεύεται πλήρως τα χαρακτηριστικά των
\textit{wide-column stores} για οργάνωση μεγάλου όγκου, χρονικά ευαίσθητων
δεδομένων.

\section{Διαχείριση Υποδομής και Cloud-Native Patterns}

Η ανάπτυξη CPS σε cloud ή υβριδικά περιβάλλοντα απαιτεί αυτοματοποιημένη
διαχείριση υποδομής και υπηρεσιών. Εδώ κυριαρχεί η χρήση πλατφόρμων όπως το
Kubernetes, που υλοποιούν:

\begin{itemize}
	\item \textbf{Δηλωτική διαχείριση (declarative infrastructure)}: Η
		επιθυμητή κατάσταση του συστήματος ορίζεται μέσω configuration,
		και ο orchestrator διασφαλίζει ότι αυτή τηρείται.
	\item \textbf{Αυτόματη κλιμάκωση (auto-scaling), αυτοΐαση
		(self-healing)}: Προσθήκη/αφαίρεση pods, επανεκκινήσεις σε
		περίπτωση αποτυχιών, health checks.
	\item \textbf{Παρατηρησιμότητα (observability)}: Συλλογή μετρικών,
		logs, tracing και alerting, με ενδεικτικά εργαλεία Prometheus,
		Grafana \cite{pragathi_prometheus_grafana}, ELK/EFK stack
		\cite{li_elk_bpm_2024}.
	\item \textbf{Διαμοιρασμός πόρων (virtualization)}: Ευνοϊκή μεθοδολογία
		για την απομόνωση εφαρμογών και την καλύτερη αξιοποίηση του
		διαθέσιμου hardware μέσω εικονικών μηχανών ή containers.
	\item \textbf{Αυτοματοποιημένος έλεγχος με Kubernetes Operators}:
		Επέκταση του control plane του Kubernetes, με αρχές
		αυτοματοποιημένων συστημάτων ελέγχου για τη διαχείριση
		σύνθετων, κατανεμημένων εφαρμογών
		\cite{coreos_operator_pattern}.
	\item \textbf{Service discovery, load balancing και secrets
		management}: Απαραίτητα για τη διασύνδεση μικροϋπηρεσιών και τη
		διατήρηση ασφάλειας και διαθεσιμότητας.
\end{itemize}

Έτσι, η υποδομή μεταμορφώνεται σε έναν ζωντανό οργανισμό που προσαρμόζεται
διαρκώς στις απαιτήσεις του συστήματος και του περιβάλλοντος, προσφέροντας
ευελιξία και ανθεκτικότητα χωρίς ανθρώπινη παρέμβαση. Με αυτόν τον τρόπο,
περιορίζονται τα λάθη του ανθρώπινου παράγοντα, καθώς κρίσιμες λειτουργίες
αυτοματοποιούνται και αναλαμβάνονται από το ίδιο το σύστημα.
