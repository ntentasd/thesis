\chapter{Θεωρητικό Υπόβαθρο}

Η εξέλιξη των Κυβερνο-Φυσικών Συστημάτων (CPS) και των εφαρμογών IoT βασίζεται σε θεμελιώδεις αρχιτεκτονικές αρχές που συνδυάζουν την αποδοτική διαχείριση της φυσικής πληροφορίας με τις δυνατότητες της σύγχρονης υπολογιστικής τεχνολογίας. Σε αυτό το κεφάλαιο παρουσιάζονται τα βασικά αρχιτεκτονικά μοντέλα, οι μέθοδοι διασύνδεσης υποσυστημάτων και τα πρότυπα διαχείρισης δεδομένων που επικρατούν στα σύγχρονα CPS.

\section{Αρχιτεκτονικές CPS και Κατανεμημένα Συστήματα}

Τα CPS δομούνται τυπικά σε τρία επίπεδα: το \textbf{φυσικό επίπεδο} (sensing/actuation), το \textbf{επίπεδο δικτύου} (networking/communication) και το \textbf{κυβερνητικό ή υπολογιστικό επίπεδο} (cyber/computation). Το φυσικό επίπεδο περιλαμβάνει αισθητήρες και ενεργοποιητές, το δίκτυο μεταφέρει τα δεδομένα, ενώ το κυβερνητικό επίπεδο διαχειρίζεται την επεξεργασία, την ανάλυση και τη λήψη αποφάσεων.

Η σύγχρονη σχεδίαση CPS ακολουθεί τα παρακάτω αρχιτεκτονικά μοτίβα:

\begin{itemize}
	\item \textbf{Layered (στρωματοποιημένη) αρχιτεκτονική}: Καθαρός διαχωρισμός φυσικών, δικτυακών και υπολογιστικών λειτουργιών, ώστε κάθε επίπεδο να εξελίσσεται, να ελέγχεται και να συντηρείται χωρίς παρεμβολές στα υπόλοιπα. Η στρωμάτωση επιβάλλει σαφή όρια ευθυνών, ενισχύει τη διαλειτουργικότητα ανάμεσα σε ετερογενείς τεχνολογίες και μειώνει το λειτουργικό κόστος μέσω προβλέψιμων διεπαφών.
	\item \textbf{Κατανεμημένη επεξεργασία}: Τα δεδομένα δεν απαιτείται να συγκεντρώνονται σε έναν κεντρικό κόμβο· μπορούν να υποβάλλονται σε τοπική ή υβριδική επεξεργασία (\textit{edge/fog computing}), μειώνοντας την καθυστέρηση και αυξάνοντας την ανθεκτικότητα. Η διαθέσιμη υπολογιστική ισχύς των αισθητήρων παραμένει κρίσιμος παράγοντας, επειδή συνήθως αποτελούν ετερογενή και χαμηλής ισχύος συστήματα με περιορισμούς σε \textit{CPU}, μνήμη και ενέργεια.

Σε τέτοιες αρχιτεκτονικές απαιτείται ακριβής αντιστοίχιση εργασιών στους κατάλληλους κόμβους, αξιοποίηση lightweight μοντέλων μηχανικής μάθησης, μηχανισμοί offloading προς ισχυρότερα επίπεδα της στοίβας και πρωτόκολλα ανοχής σφαλμάτων που λειτουργούν χωρίς κεντρικό συντονιστή.
\item \textbf{Event-driven και streaming αρχιτεκτονική}: Η επεξεργασία δεν βασίζεται σε μαζικά, περιοδικά batches. Τα δεδομένα μεταφέρονται ως συνεχείς ροές γεγονότων, επιτρέποντας συστήματα που λειτουργούν σε διαρκή ετοιμότητα. Κάθε νέο γεγονός μπορεί να ενεργοποιήσει λογική σε πραγματικό χρόνο, εξαλείφοντας τα παράθυρα αδράνειας και επιτρέποντας ακρίβεια σε δυναμικά περιβάλλοντα. Η αρχιτεκτονική αυτή απαιτεί σταθερή ροή, χαμηλή καθυστέρηση και μηχανισμούς \textit{backpressure} ώστε να διατηρείται ο έλεγχος στις αιχμές φορτίου.
	\item \textbf{Μικροϋπηρεσίες (Microservices)}: Η εφαρμογή διασπάται σε μικρές, αυτόνομες υπηρεσίες με στενά καθορισμένη λειτουργικότητα και ανεξάρτητο κύκλο ζωής. Η απομόνωση επιτρέπει ασύμμετρη κλιμάκωση, στοχευμένες αναβαθμίσεις, ταχύτερες κυκλικές εκδόσεις και περιορισμό σφαλμάτων μέσα σε σαφή όρια. Η αρχιτεκτονική απαιτεί σταθερές συμβάσεις επικοινωνίας, μηχανισμούς παρατήρησης υψηλής ανάλυσης, ανοχή σε μερικές αστοχίες και απόλυτη πειθαρχία στην αποφυγή έμμεσων εξαρτήσεων που καταστρέφουν την αυτονομία.
	\item \textbf{Loose coupling \& αναγνωσιμότητα}: Η συνεργασία των υποσυστημάτων υλοποιείται μέσω ασύγχρονων μηνυμάτων, συνήθως με \textit{pub/sub} ή \textit{event-bus} μηχανισμούς, ώστε καμία υπηρεσία να μην εξαρτάται από τη διαθεσιμότητα ή την εσωτερική δομή κάποιας άλλης. Η χαλαρή σύζευξη μειώνει τα σημεία θραύσης, αποτρέπει κυκλικές εξαρτήσεις, επιτρέπει οριζόντια κλιμάκωση χωρίς ανακατασκευή ροών και καθιστά τη συνολική συμπεριφορά του συστήματος προβλέψιμη υπό μεταβαλλόμενο φορτίο.
\end{itemize}

\section{Streams, Event-Driven και Batch vs Real-Time Processing}

Η \textit{ροή δεδομένων} (stream) αποτελεί μια συνεχώς εξελισσόμενη αλληλουχία τιμών που παράγονται από αισθητήρες, ενσωματωμένες συσκευές ή άλλες πηγές και διακινούνται ασύγχρονα εντός του συστήματος. Η συνεχής ροή επιβάλλει μοντέλο επεξεργασίας όπου τα δεδομένα αντιμετωπίζονται ως διαρκές σήμα και όχι ως στατικά σύνολα προς περιοδική ανάλυση. Η \textbf{event-driven αρχιτεκτονική} αξιοποιεί αυτό το σήμα ώστε κάθε νέο γεγονός να ενεργοποιεί αμέσως έναν υπολογισμό, μια σειρά κανόνων (rules), ενημερώσεις ή οποιεσδήποτε άλλες ελεγκτικές ενέργειες. Η μηδενική ανοχή σε καθυστερήσεις είναι θεμελιώδης σε πεδία όπως η γεωργία ακριβείας, το predictive maintenance, ο βιομηχανικός αυτοματισμός και οι αυτόνομες πλατφόρμες, όπου η πληροφορία χάνει αξία όταν παλιώνει ακόμη και κατά μερικά δευτερόλεπτα.

Τα παραδοσιακά \textit{batch} συστήματα λειτουργούν με συγκεντρωτικές παρτίδες δεδομένων, δημιουργώντας αμετάβλητη καθυστέρηση. Το μοντέλο αυτό επαρκεί μόνο όταν οι απαιτήσεις απόκρισης είναι χαμηλές ή όταν το κόστος λάθους δεν είναι κρίσιμο. Σε CPS, όμως, η καθυστέρηση ενός batch κύκλου ισοδυναμεί με απώλεια συστημικής επίγνωσης και αδυναμία δυναμικής προσαρμογής. Η μετάβαση σε \textbf{stream processing} (με αρχιτεκτονικές Lambda/Kappa) ελαχιστοποιεί το latency και επιτρέπει συνεχή αξιολόγηση της κατάστασης του συστήματος.

Η λογική ροών συνεπάγεται ανάγκη για stateful operators, μηχανισμούς windowing, backpressure και αποδοτική ανοχή σφαλμάτων, ώστε το σύστημα να παραμένει λειτουργικό υπό πίεση και ασταθείς ροές εισόδου. Η αλλαγή παραδείγματος από batch σε stream δεν αφορά μόνο τη χρονική διάσταση, αλλά και τον τρόπο μοντελοποίησης της πραγματικότητας: το σύστημα αντιμετωπίζει τα δεδομένα ως ζωντανή, κινούμενη πληροφορία και όχι ως στατικό αρχείο προς εκ των υστέρων επεξεργασία. Αυτό οδηγεί σε αρχιτεκτονικές που μπορούν να επιβάλλουν αυτονομία, να προσαρμόζονται στο περιβάλλον και να διατηρούν συστημική συνοχή χωρίς εξάρτηση από περιοδικούς κύκλους επανυπολογισμού.

\section{Αρχιτεκτονικές Streams: Lambda και Kappa}

Οι δύο επικρατέστερες αρχιτεκτονικές για επεξεργασία ροών αντιμετωπίζουν το ίδιο πρόβλημα (συνεχή, ασύγχρονη ροή δεδομένων) με διαφορετική φιλοσοφία ως προς την οργάνωση, την ακρίβεια και το λειτουργικό κόστος.

\begin{itemize}
	\item \textbf{Lambda}: Διατηρεί δύο παράλληλα επίπεδα. Το \textit{speed layer} επεξεργάζεται γεγονότα σχεδόν στιγμιαία, προσφέροντας γρήγορα αλλά ενδεχομένως προσεγγιστικά αποτελέσματα. Το \textit{batch layer} αναλαμβάνει ακριβή, πλήρη ανάλυση πάνω σε ολόκληρο το ιστορικό, ώστε τα τελικά δεδομένα να είναι συνεπή ακόμη κι όταν το \textit{fast path} παράγει προσεγγίσεις. Η αρχιτεκτονική αυτή παρέχει ισορροπία μεταξύ απόδοσης και ακρίβειας, αλλά εισάγει αυξημένη πολυπλοκότητα λόγω διπλής υλοποίησης λογικής και ανάγκης συγχρονισμού των \textit{layers}.
	\item \textbf{Kappa}: Επιλέγει ενιαίο μοντέλο ροών. Όλα τα δεδομένα αντιμετωπίζονται ως \textit{streams}, τόσο για \textit{real-time} όσο και για \textit{reprocessing}. Η επανεπεξεργασία επιτυγχάνεται απλώς με επανάγνωση του \textit{log} των γεγονότων, χωρίς ξεχωριστού \textit{batch} υποσυστήματος. Το αποτέλεσμα είναι απλούστερη λειτουργική δομή, ομοιομορφία στον κώδικα και ελαχιστοποίηση των σημείων ασυνέπειας που προκύπτουν από διπλές υλοποιήσεις. Η \textit{Kappa} απαιτεί ισχυρό και ανθεκτικό \textit{log} (π.χ. Kafka) και \textit{stateful stream processors} με ικανότητα διαχείρισης μεγάλης κατάστασης.
\end{itemize}

Η επιλογή μεταξύ των δύο εξαρτάται από την ανοχή του συστήματος σε καθυστέρηση και από το κόστος που είναι διατεθειμένο να πληρώσει ο σχεδιαστής, σε πολυπλοκότητα. Η \textbf{Lambda} ταιριάζει σε περιβάλλοντα όπου οι αναλυτικές εργασίες απαιτούν \textbf{πλήρη ακρίβεια}, χωρίς να θυσιάζεται η άμεση απόκριση. Η \textbf{Kappa} είναι καταλληλότερη όταν προέχει η \textbf{απλότητα}, η ενιαία λογική και η δυνατότητα συνεχούς επεξεργασίας χωρίς παράλληλες ροές υποδομής.

Σε πρακτικό επίπεδο, συστήματα όπως το \textit{Apache Kafka} λειτουργούν ως \textit{durable logs} που επιτρέπουν στον επεξεργαστή ροών να αναπαράγει την κατάσταση οποιαδήποτε στιγμή. Πάνω σε αυτό το υπόβαθρο, πλατφόρμες όπως \textit{Apache Flink} και \textit{Apache Spark} διαχειρίζονται παραθυροποιήσεις (\textit{windows}), \textit{stateful operators}, χρονικές εγγυήσεις (\textit{event-time processing}), ακριβή \textit{semantics} παράδοσης (ακριβώς μια φορά) και μηχανισμούς \textit{backpressure}. Αυτό επιτρέπει στις αρχιτεκτονικές \textit{Lambda} και \textit{Kappa} να λειτουργούν σε κλίμακα, να επιβάλλουν συνεκτική συμπεριφορά σε ασταθή περιβάλλοντα ρυθμού και να διασφαλίζουν ότι οι ροές δεδομένων παραμένουν χρήσιμες ακόμη και όταν οι πηγές εισόδου είναι απρόβλεπτες.

Οι δύο προσεγγίσεις δεν απαιτούν διαφορετική φιλοσοφία ως προς τα εργαλεία, αλλά διαφορετική στάση απέναντι στη μοντελοποίηση της πληροφορίας: υβριδική διπλή ανάλυση στη μία περίπτωση, μονολιθική αντίληψη ροής στην άλλη.

\section{Διασύνδεση Υποσυστημάτων}

Για την αλληλεπίδραση πολλαπλών, ετερογενών υποσυστημάτων, το \textbf{publish/subscribe} μοτίβο προσφέρει έναν θεμελιώδη μηχανισμό ασύγχρονης επικοινωνίας, επιτρέποντας χαλαρά συνδεδεμένες (\textit{loosely coupled}) υπηρεσίες. Κάθε παραγωγός (\textit{publisher}) μπορεί να στέλνει μηνύματα χωρίς να γνωρίζει τους καταναλωτές (\textit{subscribers}) και αντίστροφα, διατηρώντας την αυτονομία των υποσυστημάτων, διευκολύνοντας την επεκτασιμότητα και επιτρέποντας αλλαγές στην τοπολογία χωρίς κεντρικό συντονισμό.

Η ποιότητα υπηρεσίας (\textit{Quality of Service, QoS}) αποκτά κρίσιμη σημασία σε περιβάλλοντα με αστάθεια σύνδεσης ή περιορισμένους πόρους. Η επιλογή μεταξύ fire-and-forget, τουλάχιστον-μία-φορά (at-least-once) ή ακριβώς-μία-φορά (exactly-once) παράδοσης μηνυμάτων καθορίζει την αξιοπιστία και την ανθεκτικότητα των εφαρμογών. Σε low-power ή low-bandwidth δίκτυα, πρωτόκολλα όπως το \textit{MQTT} και το \textit{CoAP} μειώνουν το overhead, υποστηρίζοντας ελαφριά, αξιόπιστη και ασφαλή ανταλλαγή μηνυμάτων.

Πέρα από την αξιοπιστία, η διαχείριση backpressure, η αποθήκευση προσωρινών μηνυμάτων (message buffering) και η δυνατότητα replay είναι κρίσιμα στοιχεία για τη διατήρηση συνέπειας σε συστήματα με υψηλή μεταβλητότητα φόρτου. Η χρήση ιεραρχιών των topics και φιλτραρίσματος επιτρέπει στους καταναλωτές (subscribers) να λαμβάνουν μόνο τα δεδομένα που τους ενδιαφέρουν, μειώνοντας τον όγκο μεταφερόμενων μηνυμάτων και το latency.

Επιπλέον, η συνδυαστική χρήση pub/sub με event-driven αρχιτεκτονικές ενισχύει τη δυνατότητα real-time αντίδρασης σε γεγονότα. Η ενσωμάτωση μηχανισμών παρακολούθησης και metrics (π.χ. latency ανά topic, ακυρωμένα μηνύματα) επιτρέπει την ενεργή βελτιστοποίηση της επικοινωνίας και την προσαρμογή σε μεταβαλλόμενες συνθήκες δικτύου ή φόρτου.

Τελικά, η διασύνδεση υποσυστημάτων σε CPS απαιτεί προσεκτική ισορροπία μεταξύ αυτονομίας, αξιοπιστίας, latency και κατανάλωσης πόρων, με δυνατότητα κλιμάκωσης και επαναδιαμόρφωσης χωρίς διακοπή λειτουργίας.

\section{Αποθήκευση, Consistency Models και Caching}

Η αποθήκευση δεδομένων σε CPS αποτελεί κρίσιμη πρόκληση λόγω του όγκου, της ταχύτητας παραγωγής και της ανάγκης για real-time προσπέλαση. Κατανεμημένα συστήματα βάσεων δεδομένων, όπως NoSQL ή wide-column stores, χρησιμοποιούν replication, partitioning και sharding για να διασφαλίσουν υψηλή διαθεσιμότητα, fault tolerance και οριζόντια κλιμάκωση. Η επιλογή wide-column store γίνεται συχνά για την υποστήριξη μεγάλων ροών δεδομένων με ευέλικτο σχήμα και αποτελεσματική οργάνωση ανά χρονικά διαστήματα (\textit{date bucketing}), επιτρέποντας ταχεία προσπέλαση σε ιστορικά δεδομένα χωρίς να επηρεάζεται η απόδοση των real-time queries.

Η τεχνική του \textbf{date bucketing} οργανώνει τα δεδομένα σε χρονικούς “κουβάδες” ή partitions (π.χ. ανά ημέρα, ώρα ή λεπτό), μειώνοντας το εύρος σάρωσης (scan range) κατά την ανάκτηση ή ανάλυση μεγάλων όγκων δεδομένων. Σε συνδυασμό με wide-column stores, κάθε bucket μπορεί να αποθηκεύει σειρές και στήλες που αντιστοιχούν σε γεγονότα ή μετρήσεις συγκεκριμένης χρονικής περιόδου, διευκολύνοντας τόσο batch αναλύσεις όσο και real-time streaming queries χωρίς να απαιτείται πλήρης αναδιάταξη ή ανακατασκευή των δεδομένων.

Η επιλογή \textbf{consistency model} παραμένει κρίσιμη. Το strong consistency εξασφαλίζει ότι όλοι οι κόμβοι βλέπουν την ίδια κατάσταση, ενώ το eventual consistency μειώνει latency και αυξάνει διαθεσιμότητα, αποδεχόμενο προσωρινή ασυνέπεια. Causal και session-based models προσφέρουν ενδιάμεσες λύσεις, διατηρώντας λογική αλληλουχία γεγονότων χωρίς πλήρη συγχρονισμό.

Το \textit{in-memory caching} (Redis, Memcached) μειώνει δραστικά το latency για συχνά προσπελαύσιμα δεδομένα, ενώ στρατηγικές όπως write-through ή write-back ελέγχουν την αντοχή σε αποτυχίες. Η συνδυαστική χρήση cache με date bucketing επιτρέπει την άμεση πρόσβαση σε “hot” χρονικά διαστήματα χωρίς να επηρεάζεται η αποδοτικότητα ανάκτησης ιστορικών δεδομένων.

Σε CPS πραγματικού χρόνου, η οργάνωση δεδομένων με \textit{date bucketing} διευκολύνει επίσης τα \textit{stream processing pipelines}, επιτρέποντας εύκολη επανεπεξεργασία γεγονότων σε συγκεκριμένα χρονικά διαστήματα χωρίς να επηρεάζεται η συνολική δομή της βάσης. Παρακολούθηση μετρικών όπως \textit{bucket size}, \textit{cache hit/miss ratio} και \textit{latency} επιτρέπει τη βελτιστοποίηση της υποδομής και τη δυναμική προσαρμογή σε μεταβαλλόμενο φόρτο.

Η στρατηγική αυτή διασφαλίζει ισορροπία μεταξύ \textit{latency, consistency, durability} και κλιμάκωσης, ενώ εκμεταλλεύεται πλήρως τα χαρακτηριστικά των \textit{wide-column stores} για οργάνωση μεγάλου όγκου, χρονικά ευαίσθητων δεδομένων.

\section{Διαχείριση Υποδομής και Cloud-Native Patterns}

Η ανάπτυξη CPS σε cloud ή υβριδικά περιβάλλοντα απαιτεί αυτοματοποιημένη διαχείριση υποδομής και υπηρεσιών. Εδώ κυριαρχεί η χρήση πλατφόρμων όπως το Kubernetes, που υλοποιούν:

\begin{itemize}
	\item \textbf{Δηλωτική διαχείριση (declarative infrastructure)}: Η επιθυμητή κατάσταση του συστήματος ορίζεται μέσω configuration, και ο orchestrator διασφαλίζει ότι αυτή τηρείται.
	\item \textbf{Αυτόματη κλιμάκωση (auto-scaling), αυτοΐαση (self-healing)}: Προσθήκη/αφαίρεση pods, επανεκκινήσεις σε περίπτωση αποτυχιών, health checks.
	\item \textbf{Παρατηρησιμότητα (observability)}: Συλλογή μετρικών, logs, tracing και alerting, με ενδεικτικά εργαλεία Prometheus, Grafana, ELK/EFK stack.
	\item \textbf{Διαμοιρασμός πόρων (virtualization)}: Ευνοϊκή μεθοδολογία για την απομόνωση εφαρμογών και την καλύτερη αξιοποίηση του διαθέσιμου hardware μέσω εικονικών μηχανών ή containers.
	\item \textbf{Αυτοματοποιημένος έλεγχος με Kubernetes Operators}: Επέκταση του control plane του Kubernetes, με αρχές αυτοματοποιημένων συστημάτων ελέγχου για τη διαχείριση σύνθετων, κατανεμημένων εφαρμογών.
	\item \textbf{Service discovery, load balancing και secrets management}: Απαραίτητα για τη διασύνδεση μικροϋπηρεσιών και τη διατήρηση ασφάλειας και διαθεσιμότητας.
\end{itemize}

Έτσι, η υποδομή μεταμορφώνεται σε έναν ζωντανό οργανισμό που προσαρμόζεται διαρκώς στις απαιτήσεις του συστήματος και του περιβάλλοντος, προσφέροντας ευελιξία και ανθεκτικότητα χωρίς ανθρώπινη παρέμβαση. Με αυτόν τον τρόπο, περιορίζονται τα λάθη του ανθρώπινου παράγοντα, καθώς κρίσιμες λειτουργίες αυτοματοποιούνται και αναλαμβάνονται από το ίδιο το σύστημα.
