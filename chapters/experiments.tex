\chapter{Πειράματα}
\label{chap:experiments}

Η παρούσα ενότητα εξετάζει τη συμπεριφορά των μηχανισμών προσωρινής αποθήκευσης
που υποστηρίζουν το endpoint \textit{/aggregate}, το οποίο αποτελεί βασικό
συστατικό της πλατφόρμας \textit{Nostradamus}. Η υπηρεσία αυτή υλοποιεί
παραθυρικές συναθροίσεις σε χρονοσειρές αισθητήρων και λειτουργεί ως μεσαίο
επίπεδο μεταξύ της εφαρμογής και της μόνιμης βάσης δεδομένων. Η καθυστέρηση
ανάγνωσης και εγγραφής στο \textit{cache layer} μεταφέρεται άμεσα στον χρόνο
απόκρισης του \textit{API}, επομένως η απόδοση του εκάστοτε υποστρώματος
αποτελεί πρωτεύοντα παράγοντα για τη συνολική σταθερότητα της πλατφόρμας.

Πριν από την παρουσίαση των αποτελεσμάτων, αξίζει να σημειωθεί ότι το
\textit{/aggregate} είναι ιδιαίτερα ευαίσθητο σε καθυστερήσεις, επειδή κάθε
αίτημα ενεργοποιεί υπολογισμό παραθύρου με βάση πρόσφατες μετρήσεις αισθητήρων.
Το \textit{cache layer} δεν λειτουργεί ως συμπληρωματικό στοιχείο αλλά ως
κρίσιμο μέρος του χρόνου διαδρομής των αιτημάτων. Επομένως, ακόμη και μικρές
διαφορές στα \textit{percentiles} των καθυστερήσεων αντικατοπτρίζονται άμεσα
στη συνολική εμπειρία χρήσης και στη σταθερότητα της πλατφόρμας.

\section{Διατύπωση στόχου και κριτήρια αξιολόγησης}

Στόχος της πειραματικής διαδικασίας είναι η αποτίμηση της απόδοσης και της
σταθερότητας δύο πλήρως εναλλάξιμων cache drivers (\textit{Valkey},
\textit{Memcached}) όταν χρησιμοποιούνται από το \textit{/aggregate} υπό
συνθήκες συνεχούς φόρτου, όπως αυτές που προσομοιάζουν ένα αγροτικό
\textit{deployment}. Η αξιολόγηση επικεντρώνεται σε τρεις κρίσιμες παραμέτρους,
οι οποίες αντικατοπτρίζουν τις πραγματικές απαιτήσεις ενός συστήματος
\textit{IoT} με συνεχή ροή δεδομένων:

\begin{enumerate}
	\item \textbf{Απόδοση ανάγνωσης και εγγραφής ($\text{I/O}$ Latency)}.
		Εξετάζονται συμμετρικά τα μονοπάτια \textit{cache hit} και
		\textit{cache miss}, καθώς αμφότερα συνεισφέρουν στον τελικό
		χρόνο απόκρισης του endpoint \textit{/aggregate} και την
		αποφόρτιση της μόνιμης βάσης δεδομένων.
	\item \textbf{Σταθερότητα σε υψηλά percentiles (P95, P99)}. Για
		συστήματα πραγματικού χρόνου, η μέση τιμή (P50) είναι ανεπαρκής
		δείκτης. Τα υψηλά percentiles (P95 και άνω) είναι εκεί όπου
		εκδηλώνονται οι χρονικές αποκλίσεις (tail latencies) που
		επηρεάζουν ουσιαστικά την εμπειρία χρήστη και την
		προβλεψιμότητα του συστήματος.
	\item \textbf{Συμπεριφορά σε περιβάλλοντα συχνής ανανέωσης (High
		Invalidation Rate)}. Η χαμηλή χρονική διάρκεια ζωής (TTL) στις
		χρονοσειρές αισθητήρων προκαλεί συχνές invalidations και
		επαναλαμβανόμενες εισαγωγές νέων τιμών. Επομένως, ο driver
		πρέπει να ανταποκρίνεται ορθά σε workloads που χαρακτηρίζονται
		από υψηλή κινητικότητα δεδομένων.
\end{enumerate}

Οι παράμετροι αυτές δεν επιλέχθηκαν θεωρητικά αλλά προέκυψαν από πραγματικές
ανάγκες του \textit{Nostradamus}. Σε αγροτικά \textit{project}, όπου παράγονται
χιλιάδες μετρήσεις ανά λεπτό, η πλατφόρμα στηρίζεται στην ικανότητα της \textit{cache}
να προσφέρει άμεση πρόσβαση σε πρόσφατα δεδομένα ώστε να αποφεύγεται η συνεχής
επικοινωνία με την κεντρική βάση δεδομένων. Το \textbf{P95} και το \textbf{P99} θεωρούνται
ιδιαίτερα κρίσιμα, διότι οι ακραίες τιμές μπορούν να διαταράξουν τον ρυθμό με
τον οποίο διαμορφώνονται τα παράθυρα, οδηγώντας σε φαινόμενα «συσσώρευσης
καθυστερήσεων». Η επιλογή αυτών των ποσοστημορίων (percentiles) είναι ζωτικής
σημασίας για τη διαχείριση της καθυστέρησης ουράς (tail latency). Το \textbf{P95}
αντιπροσωπεύει τον μέγιστο χρόνο απόκρισης που παρατηρείται στο 95\% των
αιτημάτων, διασφαλίζοντας μια ικανοποιητική εμπειρία για τη συντριπτική
πλειοψηφία των λειτουργιών. Αντίστοιχα, το \textbf{P99} εστιάζει στο πιο αργό 1\% των
αιτημάτων, το οποίο είναι κρίσιμο σε συστήματα μεγάλης κλίμακας ή σε
λειτουργίες που αφορούν πολλαπλά βήματα, όπου ακόμη και μία σπάνια καθυστέρηση
μπορεί να οδηγήσει σε σωρευτική επιβράδυνση και να επηρεάσει αρνητικά τη λήψη
αποφάσεων σε πραγματικό χρόνο.

Το \textbf{P50} (50ό ποσοστημόριο), ή αλλιώς διάμεσος (median), αντιπροσωπεύει
τον χρόνο απόκρισης στον οποίο ολοκληρώνεται το 50\% του συνόλου των αιτημάτων.
Αυτή η μετρική περιγράφει την τυπική εμπειρία του μέσου χρήστη ή την «κανονική»
απόδοση του συστήματος. Ωστόσο, η διάμεσος δεν είναι επαρκής ως πρωταρχικός
δείκτης απόδοσης (SLI) σε συστήματα πραγματικού χρόνου, διότι είναι ευάλωτη στο
να παραπλανά, ειδικά όταν η κατανομή των καθυστερήσεων είναι ασύμμετρη (skewed)
. Αν ο μέσος χρόνος απόκρισης είναι χαμηλός, αλλά υπάρχουν πολλές σπάνιες,
αργές αποκρίσεις (ακραίες τιμές), το \textbf{P50} παραμένει σταθερό, δίνοντας
μια ψευδή αίσθηση ασφάλειας. Για το λόγο αυτό, το \textbf{P50} χρησιμοποιείται
κυρίως για τον εντοπισμό γενικευμένης υποβάθμισης της απόδοσης στην απόδοση,
αλλά η διαχείριση της ποιότητας και της αξιοπιστίας ενός κατανεμημένου
συστήματος, όπως μια πλατφόρμα \textit{IoT}, απαιτεί την παρακολούθηση των
υψηλότερων ποσοστημορίων \textbf{P95} και \textbf{P99}.

\section{Μεθοδολογία}

Για την απομόνωση των χαρακτηριστικών κάθε υποστρώματος δημιουργήθηκαν δύο
ανεξάρτητες υλοποιήσεις της πλατφόρμας: μία που χρησιμοποιεί \textit{Valkey}
και μία που χρησιμοποιεί \textit{Memcached}. Και οι δύο παραμετροποιήθηκαν μέσω
του κοινού \textit{cache} interface, ώστε η αλλαγή \textit{driver} να μην
επηρεάζει την λογική (app logic) του \textit{/aggregate}.

\subsection{Προετοιμασία και σταθεροποίηση περιβάλλοντος}

Πριν την εκτέλεση των μετρήσεων εφαρμόστηκε φάση προθέρμανσης
(\textit{warm-up}) διάρκειας 90 δευτερολέπτων. Κατά το διάστημα αυτό
σταθεροποιούνται οι εσωτερικές δομές μνήμης και μειώνονται τα
\textit{cold-start} φαινόμενα. Χωρίς αυτή τη διαδικασία, οι μετρήσεις θα
περιείχαν θόρυβο από την αρχική δέσμευση της μνήμης (allocation activity) ή από
αρχικές διεργασίες συντήρησης.

\subsection{Δομή του Πειραματικού Φορτίου}

Ο φόρτος παράχθηκε μέσω συνθετικού load generator, ο οποίος σχεδιάστηκε ώστε να
μιμείται το προφίλ αιτημάτων ενός πραγματικού γεωργικού deployment, όπου οι
συσκευές παράγουν συνεχή ροή δεδομένων. Ο φόρτος χαρακτηρίστηκε ως εξής:

\begin{itemize}
	\item \textbf{Σταθερός Ρυθμός}: Ο φόρτος διατηρήθηκε σε ένα σταθερό
		επίπεδο 350 \textit{Requests Per Second} (RPS), προσομοιώνοντας
		ένα συνεχή φόρτο εργασίας από πληθώρα συνδεδεμένων συσκευών.
	\item \textbf{Επίπεδο Ταυτόχρονης Εκτέλεσης (concurrency)}: Για την
		αξιολόγηση της σταθερότητας σε συνθήκες πίεσης, ο
		\textit{generator} χρησιμοποίησε 10 ταυτόχρονα
		threads/συνδέσεις (concurrent connections) καθ' όλη τη διάρκεια
		της δοκιμής.
	\item \textbf{Μείγμα Αιτημάτων}: Η κατανομή των λειτουργιών
		διαμορφώθηκε ώστε να αντικατοπτρίζει ένα ρεαλιστικό σενάριο
		χρήσης του \textit{API}, όπου οι περισσότερες αναγνώσεις είναι
		επιτυχημένες (Hit) και υπάρχει μια συνεχής, αλλά μικρότερη,
		ανάγκη για ανανέωση (Miss/Write):
		\begin{itemize}
			\item \textbf{Cache Hit}: 70\%
			\item \textbf{Cache Miss / Write}: 30\%
		\end{itemize}
\end{itemize}

Το πρότυπο αυτό του φορτίου ανταποκρίνεται πιστά στη φυσιολογική λειτουργία του
\textit{/aggregate}, όπου οι ίδιες μετρήσεις ανακτώνται επανειλημμένα μέσα σε
διαδοχικά παράθυρα (υψηλή πιθανότητα hit), ενώ οι νέες μετρήσεις εισάγονται με
ρυθμό που προκαλεί συνεχή εγγράφη και invalidation. Η επιλογή ενός σταθερού
ρυθμού \textit{350~RPS} βασίστηκε σε μετρήσεις πεδίου που κατέδειξαν ότι ο
συγκεκριμένος φόρτος αντιπροσωπεύει τυπικό σενάριο ενός μεσαίου αγροτικού
σταθμού.

\subsection{Παρακολούθηση και Μέτρηση}

Η συλλογή των μετρήσεων πραγματοποιήθηκε μέσω του συστήματος παρακολούθησης
\textit{Prometheus}, ενώ η οπτικοποίηση των χρονοσειρών έγινε στο
\textit{Grafana}. Δόθηκε έμφαση στην παρακολούθηση του \textit{P95 latency}, στις
καθυστερήσεις εγγραφής (write latency) και στον ρυθμό \textit{invalidations}.

Στο πλαίσιο του monitoring και του observability, ο ρυθμός των
\textit{invalidations} αποτελεί κρίσιμη μετρική, ειδικά όταν το
\textit{Time-To-Live} (\textit{TTL}) των δεδομένων ορίζεται σκόπιμα σε χαμηλή
τιμή. Τα \textit{invalidations} είναι τα συμβάντα κατά τα οποία τα αποθηκευμένα
δεδομένα κρίνονται παρωχημένα (stale) και πρέπει να απομακρυνθούν από την
\textit{cache}. Η παρακολούθηση της συχνότητας αυτών των συμβάντων είναι
απαραίτητη για δύο λόγους: 

\begin{itemize}
	\item \textbf{Πρώτον}: επιβεβαιώνεται η ορθή λειτουργία του μηχανισμού
		εκκαθάρισης, διασφαλίζοντας τη διατήρηση της επικαιρότητας των
		δεδομένων, ανάλογα με τις ανάγκες της εφαρμογής.
	\item \textbf{Δεύτερον}: παρέχεται βαθύτερη παρατηρησιμότητα στις
		επιπτώσεις που έχει αυτή η επιβαλλόμενη συχνή εκκαθάριση στους
		πόρους του συστήματος.
\end{itemize}

Ο υψηλός ρυθμός \textit{invalidations} συνεπάγεται αυξημένο υπολογιστικό κόστος
(CPU, I/O) για την ανανέωση των δεδομένων. Ο συσχετισμός του με το \textbf{P95}
\textit{read} και \textit{write latency} επιτρέπει την ακριβή αξιολόγηση της
επιβάρυνσης στην απόκριση του συστήματος, προσφέροντας έτσι κρίσιμα
\textit{insights} για τη βελτιστοποίηση των επιδόσεων.

Η βασική παραμετροποίηση των \textit{drivers} παρέμεινε στην προεπιλεγμένη
μορφή τους, εκτός από το \textit{TTL} των εγγραφών, το οποίο ορίστηκε στα 120
δευτερόλεπτα, διασφαλίζοντας ότι η πρόσβαση των \textit{drivers} γίνεται σε
δεδομένα μέγιστης επικαιρότητας, ανάλογα με τον ρυθμό συλλογής του πεδίου και
επιβάλλοντας συχνή εκκαθάριση (eviction/invalidation).

\section{Αποτελέσματα πειράματος}

Τα αποτελέσματα καταδεικνύουν σαφή διαφοροποίηση ως προς τη συμπεριφορά των δύο
υποστρωμάτων, τόσο σε επίπεδο ακατέργαστης ταχύτητας όσο και σε επίπεδο
χρονικής σταθερότητας.

\subsection{Σύγκριση καθυστέρησης}

Η ποσοτικοποίηση της καθυστέρησης στο 95ο εκατοστημόριο (P95) αποτυπώνει την
εικόνα που επηρεάζει τους περισσότερους χρήστες και επιβεβαιώνει την ταχύτητα
του Memcached.

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Μετρική} & \textbf{Memcached} ($\mu$s) & \textbf{Valkey} ($\mu$s) & \textbf{Σχετική Διαφορά} \\
		\hline
		Ανάγνωση & 486 & 878 & $\approx 1.80\times$ ταχύτερο \\
		\hline
		Εγγραφή & 2500 & 4400 & $\approx 1.76\times$ ταχύτερο \\
		\hline
	\end{tabular}
	\caption{Σύγκριση Καθυστέρησης (Latency) Valkey ένταντι Memcached στο 95ο Εκατοστημόριο (P95)}
	\label{tab:p95_comparison}
\end{table}

Όπως φαίνεται στον Πίνακα \ref{tab:p95_comparison} και επιβεβαιώνεται από το
Γράφημα \ref{fig:read_latency}, το \textit{Memcached} εμφανίζει σημαντικά
χαμηλότερη καθυστέρηση σε αναγνώσεις, με τιμές P95 που κινούνται στα $486\
\mu\text{s}$. Αυτό το αποτέλεσμα καθιστά το Memcached περίπου $1.8$ φορές
ταχύτερο από το \textit{Valkey} στην καθαρή διεκπεραίωση αιτημάτων. Η επίδοση
αυτή συνδέεται άμεσα με τον λιτό χαρακτήρα του πρωτοκόλλου του (Memcached
binary protocol) και τη φύση του ως ένα καθαρό \textit{Key-Value store}, το
οποίο αποφεύγει πολυπλοκότητα και επιτρέπει υψηλό throughput με περιορισμένο
αποτύπωμα πόρων.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{read-latency.png}
	\caption{Σύγκριση των καμπυλών καθυστέρησης ανάγνωσης (Read Latency) Valkey έναντι Memcached υπό συνεχή φόρτο (P95).}
	\label{fig:read_latency}
\end{figure}

\subsection{Ανάλυση Σταθερότητας σε Υψηλά Percentiles}

Ενώ το Memcached υπερέχει σε μέγιστη ταχύτητα I/O, όπως φαίνεται στο Γράφημα
\ref{fig:read_latency}, το \textit{Valkey} υπερέχει ως προς τη χρονική
σταθερότητα και την προβλεψιμότητα σε ακραίες συνθήκες. Αυτή η διαφορά
εκδηλώνεται ιδιαίτερα στα υψηλότερα percentiles, όπως το \textit{P99}, όπου το
\textit{Valkey} διατηρεί χαμηλότερη διακύμανση (low variance) στην καθυστέρηση.

Σε συνθήκες αύξησης του concurrency και του ρυθμού invalidations, οι καμπύλες
latency του \textit{Valkey}, αν και υψηλότερες σε μέση τιμή (P95), παρουσιάζουν
μικρότερες χρονικές αποκλίσεις και είναι λιγότερο πιθανό να εμφανίσουν τις
απότομες αιχμές (spikes) που παρατηρούνται περιστασιακά στο \textit{Memcached}
κατά την εκτέλεση εργασιών συντήρησης. Για παράδειγμα, η καθυστέρηση στο 99ο
εκατοστημόριο (P99) για το Valkey ήταν \textbf{$4.8\ \text{ms}$}, ενώ για το
Memcached, λόγω της διαχείρισης πόρων και των περιστασιακών καθυστερήσεων,
έφτασε τα \textbf{$6.1\ \text{ms}$}.

Η συμπεριφορά αυτή είναι κρίσιμη για συστήματα πραγματικού χρόνου, καθώς η
προβλεψιμότητα (deterministic latency) υπερισχύει της απόλυτης μέσης ταχύτητας.

\subsection{Συμπεριφορά σε Περιβάλλοντα Συχνής Ανανέωσης}

Η ρύθμιση του TTL στα 120 δευτερόλεπτα επέβαλε συνεχή φόρτο εκκαθάρισης και
επανεισαγωγής δεδομένων.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{write-latency.png}
	\caption{Καθυστέρηση εγγραφής (P95 Write Latency) στους δύο drivers υπό
		συνθήκες χαμηλού TTL. Η γραφική απεικόνιση αναδεικνύει τις διαφορές στη
		διαχείριση της συμφόρησης και των λειτουργιών εκκαθάρισης.}
	\label{fig:write_latency}
\end{figure}

Όπως φαίνεται στο Γράφημα \ref{fig:write_latency}, η συμπεριφορά των
δύο υποστρωμάτων παρουσιάζει ποιοτικές διαφορές κατά την εκτέλεση write
operations:

\begin{itemize}
	\item \textbf{Memcached}: Λόγω της απλής διαχείρισης μνήμης
		(εστιασμένης στην ταχύτητα), το Memcached έδειξε μεγαλύτερη
		ευαισθησία στις λειτουργίες εκκαθάρισης, οδηγώντας σε μικρές,
		αλλά μετρήσιμες, αυξήσεις στο \textit{P95/P99 latency} όταν ο
		ρυθμός \textit{invalidation} κορυφωνόταν.
	\item  \textbf{Valkey}: Η δομημένη διαχείριση της μνήμης και των
		διαδικασιών του (όπως οι πολιτικές εκκαθάρισης LRU) του
		επέτρεψαν να διατηρήσει χαμηλότερη διακύμανση (low variance)
		στην καθυστέρηση, ακόμη και όταν το υποσύστημα μνήμης ήταν υπό
		πίεση λόγω των συχνών λήξεων (expirations).
\end{itemize}

\section{Συπεράσματα και ανάλυση}

Ως εκ τούτου, τα δύο συστήματα δεν αποτελούν απλώς εναλλακτικές που διαφέρουν ποσοτικά, αλλά ποιοτικά:


\begin{itemize}
	\item \textbf{Memcached}: Επιτυγχάνει την υψηλότερη \textbf{ακατέργαστη
		ταχύτητα I/O}. Είναι ιδανικό για ελαφριές διεργασίες όπου η
		κύρια ανάγκη είναι η μέγιστη δυνατή throughput και η εφαρμογή
		χρησιμοποιεί μόνο βασικές λειτουργίες κλειδιού-τιμής.
	\item \textbf{Valkey}: Προσφέρει την υψηλότερη \textbf{χρονική
		σταθερότητα} και προβλεψιμότητα (deterministic latency), ακόμη
		και σε περιόδους υψηλής συμφόρησης. Επιπλέον, διαθέτει
		επεκτασιμότητα (π.χ., υποστήριξη για \textit{Atomic Blocks, Lua
		Scripts}, σύνθετες δομές δεδομένων) που το καθιστά
		καταλληλότερο για μελλοντική ενσωμάτωση πιο σύνθετων
		λειτουργιών της πλατφόρμας \textit{Nostradamus}.
\end{itemize}

Με δεδομένη τη \textit{modular} αρχιτεκτονική της πλατφόρμας
\textit{Nostradamus}, η επιλογή \textit{driver} μπορεί να καθοδηγείται από τις
επιχειρησιακές ανάγκες κάθε deployment, χωρίς καμία αλλαγή στον κώδικα της
εφαρμογής. Για την παρούσα, υπεραπλουστευμένη υλοποίηση (Minimum Viable Product
- MVP), το \textit{Memcached} είναι επαρκές και προτιμητέο λόγω της ανώτερης
απόδοσης $\text{I/O}$.

\section{Περαιτέρω επεκτάσεις}

Η τρέχουσα πειραματική διαδικασία αποτελεί θεμέλιο για μελλοντική ανάλυση. Ως
επεκτάσεις σχεδιάζονται:

\begin{itemize}
	\item Διερεύνηση της επίδρασης των invalidations σε διαφορετικούς
		ρυθμούς εισαγωγής νέων μετρήσεων,
	\item Αποτύπωση κατανάλωσης μνήμης και CPU ανά driver,
	\item Μελέτη συμπεριφοράς σε συνθήκες οριζόντιας κλίμακωσης,
\end{itemize}

Οι παραπάνω επεκτάσεις αποτελούν απαραίτητη συνέχεια για την πλήρη χαρτογράφηση
της συμπεριφοράς των υποστρωμάτων και για την τεκμηρίωση των επιχειρησιακών
αποφάσεων που θα καθορίσουν τη μελλοντική μορφή της πλατφόρμας.
