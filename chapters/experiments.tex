\chapter{Πειράματα}
\label{chap:experiments}

Η παρακάτω ενότητα εξετάζει τη συμπεριφορά των μηχανισμών προσωρινής
αποθήκευσης που υποστηρίζουν το endpoint \textit{/aggregate}, το οποίο αποτελεί
βασικό συστατικό της πλατφόρμας. Η υπηρεσία αυτή υλοποιεί παραθυρικές
συναθροίσεις σε χρονοσειρές αισθητήρων και λειτουργεί ως μεσαίο επίπεδο μεταξύ
της εφαρμογής και της μόνιμης βάσης δεδομένων. Η καθυστέρηση ανάγνωσης και
εγγραφής στο \textit{cache layer} μεταφέρεται άμεσα στον χρόνο απόκρισης του
\textit{API}, επομένως η απόδοση του εκάστοτε υποστρώματος αποτελεί πρωτεύοντα
παράγοντα για τη συνολική σταθερότητα της πλατφόρμας.

Πριν από την παρουσίαση των αποτελεσμάτων, αξίζει να σημειωθεί ότι το
\textit{/aggregate} είναι ιδιαίτερα ευαίσθητο σε καθυστερήσεις, επειδή κάθε
αίτημα ενεργοποιεί υπολογισμό παραθύρου με βάση πρόσφατες μετρήσεις αισθητήρων.
Το \textit{cache layer} δεν λειτουργεί ως συμπληρωματικό στοιχείο αλλά ως
κρίσιμο μέρος του χρόνου διαδρομής των αιτημάτων. Επομένως, ακόμη και μικρές
διαφορές στα \textit{percentiles} των καθυστερήσεων αντικατοπτρίζονται άμεσα
στη συνολική εμπειρία χρήσης και στη σταθερότητα της πλατφόρμας.

\section{Πειραματικό Πλαίσιο και Κοινή Μεθοδολογία}

Η πειραματική αξιολόγηση βασίζεται στη σύγκριση δύο πλήρως εναλλάξιμων cache
drivers (\textit{Valkey}, \textit{Memcached}) οι οποίοι χρησιμοποιούνται από το
endpoint \textit{/aggregate} υπό συνθήκες συνεχούς φόρτου, προσομοιώνοντας
ρεαλιστικά αγροτικά \textit{IoT deployments}.

\subsection{Στόχος και Κριτήρια Αξιολόγησης}

Στόχος της πειραματικής διαδικασίας είναι η αποτίμηση τόσο της ακατέργαστης
απόδοσης όσο και της χρονικής σταθερότητας των δύο υποστρωμάτων. Η αξιολόγηση
επικεντρώνεται σε τρεις κρίσιμες παραμέτρους:

\begin{enumerate}
	\item \textbf{Απόδοση ανάγνωσης και εγγραφής (I/O Latency)} σε σενάρια
		\textit{cache hit} και \textit{cache miss}.
	\item \textbf{Σταθερότητα σε υψηλά percentiles (P95, P99)}, όπου
		εκδηλώνονται φαινόμενα tail latency.
	\item \textbf{Συμπεριφορά υπό συχνές invalidations}, λόγω χαμηλού TTL
		και υψηλής κινητικότητας δεδομένων.
\end{enumerate}

Τα percentiles \textbf{P95} και \textbf{P99} θεωρούνται πρωτεύοντες δείκτες
απόδοσης, καθώς η διάμεσος (P50) δεν αποτυπώνει σπάνιες αλλά κρίσιμες
καθυστερήσεις που μπορούν να διαταράξουν τη λειτουργία παραθυρικών
συναθροίσεων.

\subsection{Μεθοδολογία και Παραμετροποίηση}

Για την απομόνωση των χαρακτηριστικών κάθε υποστρώματος, δημιουργήθηκαν δύο
ανεξάρτητες υλοποιήσεις της πλατφόρμας, μία με \textit{Valkey} και μία με
\textit{Memcached}, μέσω κοινού \textit{cache interface}.

Πριν από κάθε δοκιμή εφαρμόστηκε φάση \textit{warm-up} διάρκειας 90
δευτερολέπτων, ώστε να εξαλειφθούν φαινόμενα \textit{cold-start}.

Ο πειραματικός φόρτος χαρακτηρίζεται από:

\begin{itemize}
	\item Σταθερό ρυθμό 350 RPS
	\item 10 ταυτόχρονες συνδέσεις
	\item Hit/Miss ratio 70/30
	\item TTL cache entries 120 s
\end{itemize}

Η συλλογή μετρήσεων πραγματοποιήθηκε μέσω \textit{Prometheus}, με οπτικοποίηση
στο \textit{Grafana}. Ιδιαίτερη έμφαση δόθηκε στη συσχέτιση των
\textit{invalidations} με τις καθυστερήσεις εγγραφής και ανάγνωσης.

\section{Πείραμα 1: Βασική Σύγκριση Απόδοσης και Σταθερότητας Cache Drivers}

\subsection{Υπόθεση Πειράματος}

Υπό συνθήκες σταθερού και συνεχούς φόρτου, το \textit{Memcached} αναμένεται να
παρουσιάζει χαμηλότερη μέση καθυστέρηση (\textit{read/write latency}) λόγω της
απλούστερης αρχιτεκτονικής του, ενώ το \textit{Valkey} αναμένεται να εμφανίζει
μεγαλύτερη χρονική σταθερότητα και μικρότερη διακύμανση στα υψηλά
\textit{percentiles} (\textit{P95}, \textit{P99}), ιδιαίτερα σε σενάρια συχνών
\textit{invalidations}.

\subsection{Σχέδιο Πειράματος}

Η μόνη μεταβλητή του πειράματος είναι το υποκείμενο \textit{cache driver}
(\textit{Memcached} ή \textit{Valkey}).

\subsection{Δεδομένα Εισόδου}

Τα δεδομένα που ανακτώνται από το \textit{/aggregate} αντιστοιχούν σε πρόσφατα
παράθυρα χρονοσειρών αισθητήρων, οργανωμένα βάσει του σχήματος (sensor\_id,
bucket\_date). Τα δεδομένα είναι συνθετικά, αλλά βασίζονται σε πραγματικές
μετρήσεις πεδίου από αγροτικά \textit{IoT deployments} και αντικατοπτρίζουν τυπική
κατανομή προσβάσεων με υψηλή πιθανότητα επαναχρησιμοποίησης δεδομένων (cache
hits).

\subsection{Εκτέλεση Δοκιμής}

Για κάθε \textit{driver} εκτελέστηκε δοκιμή διάρκειας 10 λεπτών, μετά από φάση
σταθεροποίησης (\textit{warm\-up}) 90 δευτερολέπτων.

\subsection{Αποτελέσματα Πειράματος}

Τα αποτελέσματα καταδεικνύουν σαφή διαφοροποίηση μεταξύ των δύο υποστρωμάτων.

Στο \textbf{P95}, το \textit{Memcached} παρουσίασε χαμηλότερη καθυστέρηση τόσο
σε αναγνώσεις όσο και σε εγγραφές, με τιμές περίπου $486\ \mu s$ για read και
$2.5\ ms$ για write. Αντίστοιχα, το \textit{Valkey} κατέγραψε υψηλότερες μέσες
τιμές, γεγονός που συνάδει με την αυξημένη λειτουργική του πολυπλοκότητα.

Στα υψηλότερα percentiles, και ειδικά στο \textbf{P99}, η εικόνα αντιστρέφεται:
το \textit{Valkey} διατήρησε χαμηλότερη διακύμανση και περιορισμένες αιχμές, με
μέγιστες καθυστερήσεις περίπου $4.8\ ms$, ενώ το \textit{Memcached} παρουσίασε
σποραδικές αιχμές που έφτασαν τα $6.1\ ms$.

\subsection{Συμπεράσματα Πειράματος}

Το πείραμα επιβεβαιώνει ότι το \textit{Memcached} υπερέχει σε καθαρή απόδοση
(\textit{throughput} και χαμηλή μέση καθυστέρηση), όταν το workload είναι
ομοιόμορφο και οι καταχωρήσεις μικρές. Ωστόσο, η απλούστερη διαχείριση μνήμης το
καθιστά πιο ευάλωτο σε χρονικές αποκλίσεις υπό πίεση.

Αντίθετα, το \textit{Valkey} εμφανίζει πιο προβλέψιμη συμπεριφορά στα υψηλά
percentiles, διατηρώντας χαμηλότερη διακύμανση σε περιβάλλοντα συχνής ανανέωσης
και invalidation. Η ιδιότητα αυτή το καθιστά καταλληλότερο για συστήματα
πραγματικού χρόνου, όπου η χρονική σταθερότητα υπερισχύει της απόλυτης μέσης
ταχύτητας.

\section{Πείραμα 2: Επίδραση Υποβέλτιστης Χρονικής Πυκνότητας Δεδομένων}

\subsection{Υπόθεση πειράματος}

Η αύξηση της χρονικής πυκνότητας των μετρήσεων ανά
αισθητήρα, χωρίς αντίστοιχη αύξηση της πληροφορικής αξίας τους, οδηγεί σε
υποβέλτιστα μεγέθη ενδιάμεσων αποτελεσμάτων στο \textit{endpoint /aggregate}. Η αύξηση
αυτή αναμένεται να επηρεάσει αρνητικά την απόδοση του cache layer, ιδιαίτερα σε
όρους \textit{write latency} και \textit{tail latency}.

\subsection{Σχέδιο Πειράματος} 

Το πείραμα εκτελέστηκε ως παραλλαγή του βασικού workload. Η μοναδική μεταβολή
αφορά την πυκνότητα των εισαγόμενων μετρήσεων ανά αισθητήρα, προσομοιώνοντας
σενάρια όπου τα δεδομένα συλλέγονται σε υπερβολικά μικρά χρονικά διαστήματα.

\subsection{Δεδομένα Εισόδου}

Ορίστηκαν δύο σενάρια:

\begin{itemize}
	\item \textbf{Baseline density:} μία μέτρηση ανά αισθητήρα ανά 10 δευτερόλεπτα.
	\item \textbf{Suboptimal density:} μία μέτρηση ανά αισθητήρα ανά 1 δευτερόλεπτο.
\end{itemize}

Λόγω του σχήματος αποθήκευσης (sensor\_id, bucket\_date), η αύξηση αυτή οδηγεί
σε σημαντικά μεγαλύτερο αριθμό εγγραφών (rows) ανά partition και σε μεγαλύτερα
σύνολα δεδομένων που πρέπει να ανακτηθούν και να επεξεργαστούν από το
\textit{/aggregate endpoint}.

Τα δεδομένα είναι συνθετικά, αλλά ευθυγραμμισμένα με ρεαλιστικές αστοχίες
ρύθμισης αισθητήρων σε πραγματικά IoT deployments.

\subsection{Εκτέλεση Δοκιμής}

Για κάθε σενάριο εκτελέστηκε δοκιμή διάρκειας 10 λεπτών, μετά από warm-up 90
δευτερολέπτων.

\subsection{Αποτελέσματα Πειράματος}

Τα αποτελέσματα της δοκιμής αποτυπώνουν την επιβάρυνση που προκύπτει από την
πυκνότητα των δεδομένων στο επίπεδο αποθήκευσης και ανάκτησης.

\begin{table}[h!]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Μετρική} & \textbf{Memcached (P95)} & \textbf{Valkey (P95)} \\
        \hline
        Write Latency (baseline) & $2.5\ \text{ms}$ & $4.4\ \text{ms}$ \\
        \hline
        Write Latency (suboptimal) & $3.9\ \text{ms}$ & $5.0\ \text{ms}$ \\
        \hline
        Σχετική Αύξηση & $+56\%$\ & $+14\%$\ \\
        \hline
    \end{tabular}
    \caption{Αποτελέσματα πειράματος υπό συνθήκες υψηλού granularity δεδομένων.}
    \label{tab:exp2_results}
\end{table}

Στο 99ο ποσοστημόριο, το Memcached παρουσίασε αυξημένες αιχμές έως 7.1 ms, ενώ
το Valkey διατήρησε σταθερότερη συμπεριφορά κάτω από 5.6 ms.

\subsection{Συμπεράσματα Πειράματος}

Το πείραμα καταδεικνύει ότι η υποβέλτιστη χρονική πυκνότητα δεδομένων, ακόμη
και όταν το σχήμα αποθήκευσης και οι τύποι δεδομένων παραμένουν αμετάβλητοι,
μπορεί να οδηγήσει σε σημαντική επιβάρυνση του \textit{cache layer}. Η αύξηση
του αριθμού των μετρήσεων ανά \textit{aggregation window} διευρύνει το μέγεθος
των καταχωρήσεων στην cache και αυξάνει την πίεση στη διαχείριση μνήμης. Υπό
αυτές τις συνθήκες, το \textit{Memcached}, αν και βελτιστοποιημένο για ιδανικά
\textit{workloads} με μικρές και ομοιόμορφες καταχωρήσεις, εμφανίζει
εντονότερες αποκλίσεις στα υψηλά \textit{percentiles}. Αντίθετα, το
\textit{Valkey} διατηρεί μεγαλύτερη ανθεκτικότητα σε αυξημένο \textit{working
set} και υποβέλτιστη χρονική πυκνότητα, παρουσιάζοντας πιο προβλέψιμη
συμπεριφορά στα υψηλά \textit{percentiles}.

\section{Συμπεράσματα και ανάλυση}

Τα αποτελέσματα των πειραμάτων καταδεικνύουν ότι τα δύο υποστρώματα δεν
αποτελούν απλώς ποσοτικά εναλλακτικές λύσεις, αλλά διαφοροποιούνται ποιοτικά ως
προς τα χαρακτηριστικά απόδοσης που προκρίνουν.

Το \textbf{Memcached} μεγιστοποιεί την ακατέργαστη απόδοση \textit{I/O},
επιτυγχάνοντας χαμηλότερη μέση καθυστέρηση σε σενάρια ομοιόμορφου φορτίου και
μικρών καταχωρήσεων. Η σχεδιαστική του απλότητα και η εστίασή του σε βασικές
λειτουργίες κλειδιού--τιμής το καθιστούν κατάλληλο για περιβάλλοντα όπου η
μέγιστη δυνατή ταχύτητα υπερισχύει της χρονικής προβλεψιμότητας.

Αντίθετα, το \textbf{Valkey} εμφανίζει αυξημένη ανθεκτικότητα σε συνθήκες
αυξημένου \textit{working set}, συχνών \textit{invalidations} και υποβέλτιστης
χρονικής πυκνότητας δεδομένων, διατηρώντας χαμηλότερη διακύμανση στα υψηλά
\textit{percentiles}. Η συμπεριφορά αυτή μεταφράζεται σε μεγαλύτερη χρονική
σταθερότητα και προβλεψιμότητα (\textit{deterministic latency}), χαρακτηριστικά
κρίσιμα για συστήματα πραγματικού χρόνου. Επιπλέον, η υποστήριξη σύνθετων δομών
δεδομένων και μηχανισμών όπως \textit{Lua scripting} προσφέρει δυνατότητες
μελλοντικής λειτουργικής επέκτασης.

Με στόχο μια \textit{modular} αρχιτεκτονική, η επιλογή \textit{cache driver}
μπορεί να γίνεται με βάση τις επιχειρησιακές απαιτήσεις κάθε deployment, χωρίς
τροποποίηση της λογικής της εφαρμογής. Για την παρούσα υλοποίηση τύπου
\textit{Minimum Viable Product}, όπου προτεραιότητα αποτελεί η μέγιστη απόδοση
\textit{I/O}, το \textit{Memcached} κρίνεται επαρκές και αποδοτικό. Ωστόσο, σε
σενάρια αυξημένης πολυπλοκότητας και απαιτήσεων χρονικής σταθερότητας, το
\textit{Valkey} αναδεικνύεται ως καταλληλότερη επιλογή.

\section{Πειραματικές Προεκτάσεις}

Η παρούσα αξιολόγηση ανοίγει τον δρόμο για μια βαθύτερη πειραματική διερεύνηση
των μηχανισμών προσωρινής αποθήκευσης. Συγκεκριμένα, η μελλοντική έρευνα στο
επίπεδο των \textit{drivers} θα επικεντρωθεί στην:

\begin{itemize}
	\item \textbf{Ποσοτική ανάλυση κατανάλωσης πόρων:} Συστηματική
		συσχέτιση του \textit{I/O latency} με τη χρήση μνήμης και
		\textit{CPU} ανά \textit{driver}, για τον προσδιορισμό του
		οικονομικού κόστους (resource cost) της απόδοσης.
	\item \textbf{Δυναμική συμπεριφορά invalidations:} Μελέτη της επίδρασης
		εναλλακτικών πολιτικών εκκαθάρισης (όπως LFU ή ARC) σε σενάρια
		όπου ο ρυθμός ανανέωσης των δεδομένων υπερβαίνει τη
		χωρητικότητα της μνήμης.
	\item \textbf{Οριζόντια κλιμάκωση (clustering):} Αξιολόγηση της
		συμπεριφοράς του \textit{Valkey} και του \textit{Memcached} σε
		διατάξεις συμπλέγματος (cluster), προκειμένου να μετρηθεί η
		καθυστέρηση του συγχρονισμού των κόμβων σε συνθήκες υψηλού
		ανταγωνισμού (write contention).
\end{itemize}

Οι επεκτάσεις αυτές κρίνονται απαραίτητες για την πλήρη κατανόηση των
επιπτώσεων κάθε επιλογής σε επίπεδο συστήματος και για την ποσοτική τεκμηρίωση
των μελλοντικών αρχιτεκτονικών αποφάσεων της πλατφόρμας. Η βαθύτερη κατανόηση
των ορίων κάθε υποστρώματος (bottlenecks) θα επιτρέψει τη βέλτιστη
παραμετροποίηση της υποδομής σε περιβάλλοντα παραγωγής.
