\chapter{Πειράματα}
\label{chap:experiments}

Η παρούσα ενότητα εξετάζει τη συμπεριφορά των μηχανισμών προσωρινής αποθήκευσης
που υποστηρίζουν το endpoint \textit{/aggregate}, το οποίο αποτελεί βασικό
συστατικό της πλατφόρμας \textit{Nostradamus}. Η υπηρεσία αυτή υλοποιεί
παραθυρικές συναθροίσεις σε χρονοσειρές αισθητήρων και λειτουργεί ως μεσαίο
επίπεδο μεταξύ της εφαρμογής και της μόνιμης βάσης δεδομένων. Η καθυστέρηση
ανάγνωσης και εγγραφής στο cache layer μεταφέρεται άμεσα στον χρόνο απόκρισης
του API, επομένως η απόδοση του εκάστοτε υποστρώματος αποτελεί πρωτεύοντα
παράγοντα για τη συνολική σταθερότητα της πλατφόρμας.

\section{Διατύπωση στόχου και κριτήρια αξιολόγησης}

Στόχος της πειραματικής διαδικασίας είναι η αποτίμηση της απόδοσης και της
σταθερότητας δύο πλήρως εναλλάξιμων cache drivers (\textit{Valkey},
\textit{Memcached}) όταν χρησιμοποιούνται από το \textit{/aggregate} υπό
συνθήκες συνεχούς φόρτου, όπως αυτές που προσομοιάζουν ένα αγροτικό
deployment.Η αξιολόγηση επικεντρώνεται σε τρεις κρίσιμες παραμέτρους, οι οποίες
αντικατοπτρίζουν τις πραγματικές απαιτήσεις ενός συστήματος IoT με συνεχή ροή
δεδομένων:

\begin{enumerate}
	\item \textbf{Απόδοση ανάγνωσης και εγγραφής ($\text{I/O}$ Latency)}.
		Εξετάζονται συμμετρικά τα μονοπάτια \textit{cache hit} και
		\textit{cache miss}, καθώς αμφότερα συνεισφέρουν στον τελικό
		χρόνο απόκρισης του endpoint \textit{/aggregate} και την
		αποφόρτιση της μόνιμης βάσης δεδομένων.
	\item \textbf{Σταθερότητα σε υψηλά percentiles (P95, P99)}. Για
		συστήματα πραγματικού χρόνου, η μέση τιμή (P50) είναι ανεπαρκής
		δείκτης. Τα υψηλά percentiles (P95 και άνω) είναι εκεί όπου
		εκδηλώνονται οι χρονικές αποκλίσεις (tail latencies) που
		επηρεάζουν ουσιαστικά την εμπειρία χρήστη και την
		προβλεψιμότητα του συστήματος.
	\item \textbf{Συμπεριφορά σε περιβάλλοντα συχνής ανανέωσης (High
		Invalidation Rate)}. Η χαμηλή χρονική διάρκεια ζωής (TTL) στις
		χρονοσειρές αισθητήρων προκαλεί συχνές invalidations και
		επαναλαμβανόμενες εισαγωγές νέων τιμών. Επομένως, ο driver
		πρέπει να ανταποκρίνεται ορθά σε workloads που χαρακτηρίζονται
		από υψηλή κινητικότητα δεδομένων.
\end{enumerate}

Οι παραπάνω στόχοι αποτυπώνουν τις πραγματικές απαιτήσεις ενός αγροτικού
deployment, όπου οι συσκευές παράγουν συνεχή ροή δεδομένων και το API πρέπει να
διατηρεί σταθερή συμπεριφορά ακόμα και υπό μεταβαλλόμενο φόρτο.

\section{Μεθοδολογία}

Για την απομόνωση των χαρακτηριστικών κάθε υποστρώματος δημιουργήθηκαν δύο
ανεξάρτητες instantiations της πλατφόρμας: μία που χρησιμοποιεί \textit{Valkey}
και μία που χρησιμοποιεί \textit{Memcached}. Και οι δύο παραμετροποιήθηκαν μέσω
του κοινού cache interface, ώστε η αλλαγή driver να μην επηρεάζει την
εφαρμοστική λογική του \textit{/aggregate}.

\subsection{Δομή του Πειραματικού Φορτίου}

Ο φόρτος παράχθηκε μέσω συνθετικού load generator, ο οποίος σχεδιάστηκε ώστε να
μιμείται το προφίλ αιτημάτων ενός πραγματικού γεωργικού deployment, όπου οι
συσκευές παράγουν συνεχή ροή δεδομένων. Ο φόρτος χαρακτηρίστηκε ως εξής:

\begin{itemize}
	\item \textbf{Σταθερός Ρυθμός}: Ο φόρτος διατηρήθηκε σε ένα σταθερό
		επίπεδο 350 \textit{Requests Per Second} (RPS), προσομοιώνοντας ένα
		συνεχή φόρτο εργασίας από πληθώρα συνδεδεμένων συσκευών.
	\item \textbf{Επίπεδο Ταυτόχρονης Εκτέλεσης (concurrency)}:
		Για την αξιολόγηση της σταθερότητας σε συνθήκες πίεσης, ο
		\textit{generator} χρησιμοποίησε 10 ταυτόχρονα
		threads/συνδέσεις (concurrent connections) καθ' όλη τη
		διάρκεια της δοκιμής.
	\item \textbf{Μείγμα Αιτημάτων}: Η κατανομή των λειτουργιών
		διαμορφώθηκε ώστε να αντικατοπτρίζει ένα ρεαλιστικό σενάριο
		χρήσης του \textit{API}, όπου οι περισσότερες αναγνώσεις είναι
		επιτυχημένες (Hit) και υπάρχει μια συνεχής, αλλά μικρότερη,
		ανάγκη για ανανέωση (Miss/Write):
		\begin{itemize}
			\item \textbf{Cache Hit}: 70\%
			\item \textbf{Cache Miss / Write}: 30\%
		\end{itemize}
\end{itemize}

\subsection{Παρακολούθηση και Μέτρηση}

Η συλλογή των μετρήσεων πραγματοποιήθηκε μέσω του συστήματος παρακολούθησης
\textit{Prometheus}, ενώ η οπτικοποίηση των χρονοσειρών έγινε στο
\textit{Grafana}. Δόθηκε έμφαση στην παρακολούθηση του \textit{P95 latency}, στις
καθυστερήσεις εγγραφής (Write Latency) και στον ρυθμό \textit{invalidations}.

Η βασική παραμετροποίηση των drivers παρέμεινε στην προεπιλεγμένη μορφή τους,
εκτός από το \textit{TTL} των εγγραφών, το οποίο ορίστηκε στα 120 δευτερόλεπτα,
προσεγγίζοντας έτσι τον λειτουργικό ορίζοντα των μετρήσεων πεδίου και
επιβάλλοντας συχνή εκκαθάριση (eviction/invalidation).

\section{Αποτελέσματα πειράματος}

Τα αποτελέσματα καταδεικνύουν σαφή διαφοροποίηση ως προς τη συμπεριφορά των δύο
υποστρωμάτων, τόσο σε επίπεδο ακατέργαστης ταχύτητας όσο και σε επίπεδο
χρονικής σταθερότητας.

\subsection{Σύγκριση καθυστέρησης}

Η ποσοτικοποίηση της καθυστέρησης στο 95ο εκατοστημόριο (P95) αποτυπώνει την
εικόνα που επηρεάζει τους περισσότερους χρήστες και επιβεβαιώνει την ταχύτητα
του Memcached.

\break

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Μετρική} & \textbf{Memcached} ($\mu$s) & \textbf{Valkey} ($\mu$s) & \textbf{Σχετική Διαφορά} \\
		\hline
		Ανάγνωση & 486 & 878 & $\approx 1.80\times$ ταχύτερο \\
		\hline
		Εγγραφή & 2500 & 4400 & $\approx 1.76\times$ ταχύτερο \\
		\hline
	\end{tabular}
	\caption{Σύγκριση Καθυστέρησης (Latency) Valkey ένταντι Memcached στο 95ο Εκατοστημόριο (P95)}
	\label{tab:p95_comparison}
\end{table}

Όπως φαίνεται στον Πίνακα \ref{tab:p95_comparison} και επιβεβαιώνεται από το
Γράφημα \ref{fig:read_latency}, το \textit{Memcached} εμφανίζει σημαντικά
χαμηλότερη καθυστέρηση σε αναγνώσεις, με τιμές P95 που κινούνται στα $486\
\mu\text{s}$. Αυτό το αποτέλεσμα καθιστά το Memcached περίπου $1.8$ φορές
ταχύτερο από το \textit{Valkey} στην καθαρή διεκπεραίωση αιτημάτων. Η επίδοση
αυτή συνδέεται άμεσα με τον λιτό χαρακτήρα του πρωτοκόλλου του (Memcached
binary protocol) και τη φύση του ως ένα καθαρό \textit{Key-Value store}, το
οποίο αποφεύγει πολυπλοκότητα και επιτρέπει υψηλό throughput με περιορισμένο
αποτύπωμα πόρων.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{read-latency.png}
	\caption{Σύγκριση των καμπυλών καθυστέρησης ανάγνωσης (Read Latency) Valkey έναντι Memcached υπό συνεχή φόρτο (P95).}
	\label{fig:read_latency}
\end{figure}

\subsection{Ανάλυση Σταθερότητας σε Υψηλά Percentiles}

Ενώ το Memcached υπερέχει σε μέγιστη ταχύτητα I/O, όπως φαίνεται στο Γράφημα
\ref{fig:read_latency}, το \textit{Valkey} υπερέχει ως προς τη χρονική
σταθερότητα και την προβλεψιμότητα σε ακραίες συνθήκες. Αυτή η διαφορά
εκδηλώνεται ιδιαίτερα στα υψηλότερα percentiles, όπως το \textit{P99}, όπου το
\textit{Valkey} διατηρεί χαμηλότερη διακύμανση (low variance) στην καθυστέρηση.

Σε συνθήκες αύξησης του concurrency και του ρυθμού invalidations, οι καμπύλες
latency του \textit{Valkey}, αν και υψηλότερες σε μέση τιμή (P95), παρουσιάζουν
μικρότερες χρονικές αποκλίσεις και είναι λιγότερο πιθανό να εμφανίσουν τις
απότομες αιχμές (spikes) που παρατηρούνται περιστασιακά στο \textit{Memcached}
κατά την εκτέλεση εργασιών συντήρησης. Για παράδειγμα, η καθυστέρηση στο 99ο
εκατοστημόριο (P99) για το Valkey ήταν \textbf{$4.8\ \text{ms}$}, ενώ για το
Memcached, λόγω της διαχείρισης πόρων και των περιστασιακών καθυστερήσεων,
έφτασε τα \textbf{$6.1\ \text{ms}$}.

Η συμπεριφορά αυτή είναι κρίσιμη για συστήματα πραγματικού χρόνου, καθώς η
προβλεψιμότητα (deterministic latency) υπερισχύει της απόλυτης μέσης ταχύτητας.

\subsection{Συμπεριφορά σε Περιβάλλοντα Συχνής Ανανέωσης}

Η ρύθμιση του TTL στα 120 δευτερόλεπτα επέβαλε συνεχή φόρτο εκκαθάρισης και
επανεισαγωγής δεδομένων.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{write-latency.png}
	\caption{Καθυστέρηση εγγραφής (P95 Write Latency) στους δύο drivers υπό
		συνθήκες χαμηλού TTL. Η γραφική απεικόνιση αναδεικνύει τις διαφορές στη
		διαχείριση της συμφόρησης και των λειτουργιών εκκαθάρισης.}
	\label{fig:write_latency}
\end{figure}

Όπως φαίνεται στο Γράφημα \ref{fig:write_latency}, η συμπεριφορά των
δύο υποστρωμάτων παρουσιάζει ποιοτικές διαφορές κατά την εκτέλεση write
operations:

\begin{itemize}
	\item \textbf{Memcached}: Λόγω της απλής διαχείρισης μνήμης
		(εστιασμένης στην ταχύτητα), το Memcached έδειξε μεγαλύτερη
		ευαισθησία στις λειτουργίες εκκαθάρισης, οδηγώντας σε μικρές,
		αλλά μετρήσιμες, αυξήσεις στο \textit{P95/P99 latency} όταν ο
		ρυθμός \textit{invalidation} κορυφωνόταν.
	\item  \textbf{Valkey}: Η δομημένη διαχείριση της μνήμης και των
		διαδικασιών του (όπως οι πολιτικές εκκαθάρισης LRU) του
		επέτρεψαν να διατηρήσει χαμηλότερη διακύμανση (low variance)
		στην καθυστέρηση, ακόμη και όταν το υποσύστημα μνήμης ήταν υπό
		πίεση λόγω των συχνών λήξεων (expirations).
\end{itemize}

\section{Συπεράσματα και ανάλυση}

Ως εκ τούτου, τα δύο συστήματα δεν αποτελούν απλώς εναλλακτικές που διαφέρουν ποσοτικά, αλλά ποιοτικά:


\begin{itemize}
	\item \textbf{Memcached}: Επιτυγχάνει την υψηλότερη \textbf{ακατέργαστη
		ταχύτητα I/O}. Είναι ιδανικό για ελαφριές διεργασίες όπου η
		κύρια ανάγκη είναι η μέγιστη δυνατή throughput και η εφαρμογή
		χρησιμοποιεί μόνο βασικές λειτουργίες κλειδιού-τιμής.
	\item \textbf{Valkey}: Προσφέρει την υψηλότερη \textbf{χρονική
		σταθερότητα} και προβλεψιμότητα (deterministic latency), ακόμη
		και σε περιόδους υψηλής συμφόρησης. Επιπλέον, διαθέτει
		επεκτασιμότητα (π.χ., υποστήριξη για \textit{Atomic Blocks, Lua
		Scripts}, σύνθετες δομές δεδομένων) που το καθιστά
		καταλληλότερο για μελλοντική ενσωμάτωση πιο σύνθετων
		λειτουργιών της πλατφόρμας \textit{Nostradamus}.
\end{itemize}

Με δεδομένη τη \textit{modular} αρχιτεκτονική της πλατφόρμας
\textit{Nostradamus}, η επιλογή \textit{driver} μπορεί να καθοδηγείται από τις
επιχειρησιακές ανάγκες κάθε deployment, χωρίς καμία αλλαγή στον κώδικα της
εφαρμογής. Για την παρούσα, υπεραπλουστευμένη υλοποίηση (Minimum Viable Product
- MVP), το \textit{Memcached} είναι επαρκές και προτιμητέο λόγω της ανώτερης
απόδοσης $\text{I/O}$.

\section{Περαιτέρω επεκτάσεις}

Η τρέχουσα πειραματική διαδικασία αποτελεί θεμέλιο για μελλοντική ανάλυση. Ως
επεκτάσεις σχεδιάζονται:

\begin{itemize}
	\item Διερεύνηση της επίδρασης των invalidations σε διαφορετικούς ρυθμούς εισαγωγής
		νέων μετρήσεων,
	\item Αποτύπωση κατανάλωσης μνήμης και CPU ανά driver,
	\item Μελέτη συμπεριφοράς σε συνθήκες οριζόντιας κλίμακωσης,
\end{itemize}

Οι παραπάνω επεκτάσεις αποτελούν απαραίτητη συνέχεια για την πλήρη χαρτογράφηση
της συμπεριφοράς των υποστρωμάτων και για την τεκμηρίωση των επιχειρησιακών
αποφάσεων που θα καθορίσουν τη μελλοντική μορφή της πλατφόρμας.
